/*
 * This file was generated by:
 * ..\..\cio-panda3d-3\built_x64\bin\interrogate -D__inline -DCPPPARSER -DP3_INTERROGATE=1 -D__cplusplus -fnames -string -refcount -assert -S..\..\cio-panda3d-3\built_x64\include\parser-inc -S..\..\cio-panda3d-3\built_x64\include -I..\..\cio-panda3d-3\built_x64\include -Isource -oc ccoginvasion_igate.cpp -od ccoginvasion.in -python-native -module ccoginvasion -library ccoginvasion -Dvolatile= -DINTERROGATE -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -D__inline -D_X86_ -DWIN32_VC -DWIN32 -D_WIN32 -D_MSC_VER=1600 -D__declspec(param)= -D__cdecl -D_near -D_far -D__near -D__far -D__stdcall source\audioclip.h source\cNametag.h source\cNametag3d.h source\config_ccoginvasion.h source\ct_musicdata.h source\ct_musicmgr.h source\lerper.h source\smartcamera_bullet.h source\suitpathfinder_ai.h
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include <Python.h>
#include <asyncTaskManager.h>
#include <audioSound.h>
#include "audioclip.h"
#include "audiomanager.h"
#include <cmath>
#include "cnametag.h"
#include <configVariableDouble.h>
#include <configVariableInt.h>
#include <configVariableString.h>
#include "config_ccoginvasion.h"
#include "ct_musicdata.h"
#include <fstream>
#include <genericAsyncTask.h>
#include <iostream>
#include <lmatrix.h>
#include <lpoint3.h>
#include <lvector2.h>
#include <map>
#include <nodePath.h>
#include <notifyCategoryProxy.h>
#include <pandabase.h>
#include <py_panda.h>
#include <referenceCount.h>
#include "source/audioclip.h"
#include "source/cNametag.h"
#include "source/cNametag3d.h"
#include "source/config_ccoginvasion.h"
#include "source/ct_musicdata.h"
#include "source/ct_musicmgr.h"
#include "source/lerper.h"
#include "source/smartcamera_bullet.h"
#include "source/suitpathfinder_ai.h"
#include <string>
#include <threadPriority.h>
#include <throw_event.h>
#include <vector>

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class AudioClip
 */
typedef AudioClip AudioClip_localtype;
Define_Module_Class(ccoginvasion, AudioClip, AudioClip_localtype, AudioClip);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AudioClip = &Dtool_AudioClip;
static void Dtool_PyModuleClassInit_AudioClip(PyObject *module);

/**
 * Forward declarations for top-level class CNametag
 */
typedef CNametag CNametag_localtype;
Define_Module_Class(ccoginvasion, CNametag, CNametag_localtype, CNametag);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CNametag = &Dtool_CNametag;
static void Dtool_PyModuleClassInit_CNametag(PyObject *module);

/**
 * Forward declarations for top-level class CNametag3d
 */
typedef CNametag3d CNametag3d_localtype;
Define_Module_Class(ccoginvasion, CNametag3d, CNametag3d_localtype, CNametag3d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CNametag3d = &Dtool_CNametag3d;
static void Dtool_PyModuleClassInit_CNametag3d(PyObject *module);

/**
 * Forward declarations for top-level class CTMusicData
 */
typedef CTMusicData CTMusicData_localtype;
Define_Module_Class(ccoginvasion, CTMusicData, CTMusicData_localtype, CTMusicData);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CTMusicData = &Dtool_CTMusicData;
static void Dtool_PyModuleClassInit_CTMusicData(PyObject *module);

/**
 * Forward declarations for top-level class CTMusicManager
 */
typedef CTMusicManager CTMusicManager_localtype;
Define_Module_Class(ccoginvasion, CTMusicManager, CTMusicManager_localtype, CTMusicManager);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CTMusicManager = &Dtool_CTMusicManager;
static void Dtool_PyModuleClassInit_CTMusicManager(PyObject *module);

/**
 * Forward declarations for top-level class Lerper
 */
typedef Lerper Lerper_localtype;
Define_Module_Class(ccoginvasion, Lerper, Lerper_localtype, Lerper);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Lerper = &Dtool_Lerper;
static void Dtool_PyModuleClassInit_Lerper(PyObject *module);

/**
 * Forward declarations for top-level class SuitPathFinderAI
 */
typedef SuitPathFinderAI SuitPathFinderAI_localtype;
Define_Module_Class(ccoginvasion, SuitPathFinderAI, SuitPathFinderAI_localtype, SuitPathFinderAI);
static struct Dtool_PyTypedObject *const Dtool_Ptr_SuitPathFinderAI = &Dtool_SuitPathFinderAI;
static void Dtool_PyModuleClassInit_SuitPathFinderAI(PyObject *module);
SuitPathFinderAI *Dtool_Coerce_SuitPathFinderAI(PyObject *args, SuitPathFinderAI &coerced);

/**
 * Declarations for exported classes
 */
static const Dtool_TypeDef exports[] = {
  {"AudioClip", &Dtool_AudioClip},
  {"CNametag", &Dtool_CNametag},
  {"CNametag3d", &Dtool_CNametag3d},
  {"CTMusicData", &Dtool_CTMusicData},
  {"CTMusicManager", &Dtool_CTMusicManager},
  {"Lerper", &Dtool_Lerper},
  {"SuitPathFinderAI", &Dtool_SuitPathFinderAI},
  {nullptr, nullptr},
};

/**
 * Extern declarations for imported classes
 */
#ifndef LINK_ALL_STATIC
static Dtool_TypeDef imports[] = {
  {"LPoint3f", nullptr},
#define Dtool_Ptr_LPoint3f (imports[0].type)
  {nullptr, nullptr},
};
#endif

// LPoint3f
#ifndef LINK_ALL_STATIC
inline static LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced) {
  nassertr(Dtool_Ptr_LPoint3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LPoint3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LPoint3f *(*)(PyObject *, LPoint3f &))Dtool_Ptr_LPoint3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint3f = &Dtool_LPoint3f;
extern LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced);
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class AudioClip
 */
/**
 * Python function wrapper for:
 * static std::string const AudioClip::get_clip_done_event(void)
 */
static PyObject *Dtool_AudioClip_get_clip_done_event_2(PyObject *, PyObject *) {
  // 1-static std::string const AudioClip::get_clip_done_event(void)
  std::string const return_value = (AudioClip::get_clip_done_event)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioClip_get_clip_done_event_2_comment =
  "C++ Interface:\n"
  "get_clip_done_event()\n";
#else
static const char *Dtool_AudioClip_get_clip_done_event_2_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static std::string const AudioClip::get_part_done_event(void)
 */
static PyObject *Dtool_AudioClip_get_part_done_event_3(PyObject *, PyObject *) {
  // 1-static std::string const AudioClip::get_part_done_event(void)
  std::string const return_value = (AudioClip::get_part_done_event)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioClip_get_part_done_event_3_comment =
  "C++ Interface:\n"
  "get_part_done_event()\n";
#else
static const char *Dtool_AudioClip_get_part_done_event_3_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline AudioClip::AudioClip(AudioClip const &) = default
 */
static int Dtool_Init_AudioClip(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("AudioClip() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline AudioClip::AudioClip(AudioClip const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    AudioClip const *param0_this = (AudioClip *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_AudioClip, 0, "AudioClip.AudioClip", true, true);
    if (param0_this != nullptr) {
      AudioClip *return_value = new AudioClip(*param0_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AudioClip, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AudioClip(const AudioClip param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_AudioClip(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_AudioClip) {
    printf("AudioClip ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  AudioClip *local_this = (AudioClip *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_AudioClip) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_AudioClip(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_AudioClip) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CNametag
 */
/**
 * Python function wrapper for:
 * void CNametag::set_chatballoon_size(double width, double height)
 */
static PyObject *Dtool_CNametag_set_chatballoon_size_9(PyObject *self, PyObject *args, PyObject *kwds) {
  CNametag *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CNametag, (void **)&local_this, "CNametag.set_chatballoon_size")) {
    return nullptr;
  }
  // 1-void CNametag::set_chatballoon_size(double width, double height)
  double param1;
  double param2;
  static const char *keyword_list[] = {"width", "height", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "dd:set_chatballoon_size", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_chatballoon_size)((double)param1, (double)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_chatballoon_size(const CNametag self, double width, double height)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CNametag_set_chatballoon_size_9_comment =
  "C++ Interface:\n"
  "set_chatballoon_size(const CNametag self, double width, double height)\n";
#else
static const char *Dtool_CNametag_set_chatballoon_size_9_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CNametag::set_panel_size(double width, double height)
 */
static PyObject *Dtool_CNametag_set_panel_size_10(PyObject *self, PyObject *args, PyObject *kwds) {
  CNametag *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CNametag, (void **)&local_this, "CNametag.set_panel_size")) {
    return nullptr;
  }
  // 1-void CNametag::set_panel_size(double width, double height)
  double param1;
  double param2;
  static const char *keyword_list[] = {"width", "height", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "dd:set_panel_size", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_panel_size)((double)param1, (double)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_panel_size(const CNametag self, double width, double height)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CNametag_set_panel_size_10_comment =
  "C++ Interface:\n"
  "set_panel_size(const CNametag self, double width, double height)\n";
#else
static const char *Dtool_CNametag_set_panel_size_10_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CNametag::get_chatballoon_region(PyObject *list)
 */
static PyObject *Dtool_CNametag_get_chatballoon_region_12(PyObject *self, PyObject *arg) {
  CNametag *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CNametag, (void **)&local_this, "CNametag.get_chatballoon_region")) {
    return nullptr;
  }
  // 1-void CNametag::get_chatballoon_region(PyObject *list)
  ((*local_this).get_chatballoon_region)(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_chatballoon_region(const CNametag self, object list)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CNametag_get_chatballoon_region_12_comment =
  "C++ Interface:\n"
  "get_chatballoon_region(const CNametag self, object list)\n";
#else
static const char *Dtool_CNametag_get_chatballoon_region_12_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * CNametag::CNametag(void)
 * inline CNametag::CNametag(CNametag const &) = default
 */
static int Dtool_Init_CNametag(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("CNametag() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-CNametag::CNametag(void)
      CNametag *return_value = new CNametag();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CNametag, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline CNametag::CNametag(CNametag const &) = default
      CNametag const *arg_this = (CNametag *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CNametag, 0, "CNametag.CNametag", true, true);
      if (arg_this != nullptr) {
        CNametag *return_value = new CNametag(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CNametag, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CNametag() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CNametag()\n"
      "CNametag(const CNametag param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CNametag(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CNametag) {
    printf("CNametag ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CNametag *local_this = (CNametag *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CNametag) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CNametag(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CNametag) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CNametag3d
 */
/**
 * Python function wrapper for:
 * void CNametag3d::get_chatballoon_region(LPoint3f const &center, double height_3d, PyObject *list)
 */
static PyObject *Dtool_CNametag3d_get_chatballoon_region_15(PyObject *self, PyObject *args, PyObject *kwds) {
  CNametag3d *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CNametag3d, (void **)&local_this, "CNametag3d.get_chatballoon_region")) {
    return nullptr;
  }
  // 1-void CNametag3d::get_chatballoon_region(LPoint3f const &center, double height_3d, PyObject *list)
  PyObject *param1;
  double param2;
  PyObject *param3;
  static const char *keyword_list[] = {"center", "height_3d", "list", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OdO:get_chatballoon_region", (char **)keyword_list, &param1, &param2, &param3)) {
    LPoint3f param1_local;
    LPoint3f const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "CNametag3d.get_chatballoon_region", "LPoint3f");
    }
    ((*local_this).get_chatballoon_region)(*param1_this, (double)param2, param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_chatballoon_region(const CNametag3d self, const LPoint3f center, double height_3d, object list)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CNametag3d_get_chatballoon_region_15_comment =
  "C++ Interface:\n"
  "get_chatballoon_region(const CNametag3d self, const LPoint3f center, double height_3d, object list)\n";
#else
static const char *Dtool_CNametag3d_get_chatballoon_region_15_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * double CNametag3d::get_scale(double distance, double scale_factor)
 */
static PyObject *Dtool_CNametag3d_get_scale_16(PyObject *self, PyObject *args, PyObject *kwds) {
  CNametag3d *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CNametag3d, (void **)&local_this, "CNametag3d.get_scale")) {
    return nullptr;
  }
  // 1-double CNametag3d::get_scale(double distance, double scale_factor)
  double param1;
  double param2;
  static const char *keyword_list[] = {"distance", "scale_factor", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "dd:get_scale", (char **)keyword_list, &param1, &param2)) {
    double return_value = ((*local_this).get_scale)((double)param1, (double)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_scale(const CNametag3d self, double distance, double scale_factor)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CNametag3d_get_scale_16_comment =
  "C++ Interface:\n"
  "get_scale(const CNametag3d self, double distance, double scale_factor)\n";
#else
static const char *Dtool_CNametag3d_get_scale_16_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CNametag3d::CNametag3d(void) = default
 * inline CNametag3d::CNametag3d(CNametag3d const &) = default
 */
static int Dtool_Init_CNametag3d(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("CNametag3d() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline CNametag3d::CNametag3d(void) = default
      CNametag3d *return_value = new CNametag3d();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CNametag3d, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline CNametag3d::CNametag3d(CNametag3d const &) = default
      CNametag3d const *arg_this = (CNametag3d *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CNametag3d, 0, "CNametag3d.CNametag3d", true, true);
      if (arg_this != nullptr) {
        CNametag3d *return_value = new CNametag3d(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CNametag3d, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CNametag3d() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CNametag3d()\n"
      "CNametag3d(const CNametag3d param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CNametag3d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CNametag3d) {
    printf("CNametag3d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CNametag3d *local_this = (CNametag3d *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CNametag3d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CNametag) {
    return (CNametag *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CNametag3d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CNametag3d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CNametag) {
    CNametag* other_this = (CNametag*)from_this;
    return (CNametag3d*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CTMusicData
 */
/**
 * Python function wrapper for:
 * static void CTMusicData::initialize_chunk_data(void)
 */
static PyObject *Dtool_CTMusicData_initialize_chunk_data_22(PyObject *, PyObject *) {
  // 1-static void CTMusicData::initialize_chunk_data(void)
  (CTMusicData::initialize_chunk_data)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CTMusicData_initialize_chunk_data_22_comment =
  "C++ Interface:\n"
  "initialize_chunk_data()\n";
#else
static const char *Dtool_CTMusicData_initialize_chunk_data_22_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static void CTMusicData::stop_am_update_task(void)
 */
static PyObject *Dtool_CTMusicData_stop_am_update_task_23(PyObject *, PyObject *) {
  // 1-static void CTMusicData::stop_am_update_task(void)
  (CTMusicData::stop_am_update_task)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CTMusicData_stop_am_update_task_23_comment =
  "C++ Interface:\n"
  "stop_am_update_task()\n";
#else
static const char *Dtool_CTMusicData_stop_am_update_task_23_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * CTMusicData::CTMusicData(void)
 * inline CTMusicData::CTMusicData(CTMusicData const &) = default
 */
static int Dtool_Init_CTMusicData(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("CTMusicData() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-CTMusicData::CTMusicData(void)
      CTMusicData *return_value = new CTMusicData();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CTMusicData, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline CTMusicData::CTMusicData(CTMusicData const &) = default
      CTMusicData const *arg_this = (CTMusicData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CTMusicData, 0, "CTMusicData.CTMusicData", true, true);
      if (arg_this != nullptr) {
        CTMusicData *return_value = new CTMusicData(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CTMusicData, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CTMusicData() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CTMusicData()\n"
      "CTMusicData(const CTMusicData param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CTMusicData(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CTMusicData) {
    printf("CTMusicData ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CTMusicData *local_this = (CTMusicData *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CTMusicData) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CTMusicData(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CTMusicData) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CTMusicManager
 */
/**
 * Python function wrapper for:
 * static void CTMusicManager::spawn_load_tournament_music_task(void)
 */
static PyObject *Dtool_CTMusicManager_spawn_load_tournament_music_task_27(PyObject *, PyObject *) {
  // 1-static void CTMusicManager::spawn_load_tournament_music_task(void)
  (CTMusicManager::spawn_load_tournament_music_task)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CTMusicManager_spawn_load_tournament_music_task_27_comment =
  "C++ Interface:\n"
  "spawn_load_tournament_music_task()\n";
#else
static const char *Dtool_CTMusicManager_spawn_load_tournament_music_task_27_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CTMusicManager::set_clip_request(std::string const &clip)
 */
static PyObject *Dtool_CTMusicManager_set_clip_request_28(PyObject *self, PyObject *arg) {
  CTMusicManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CTMusicManager, (void **)&local_this, "CTMusicManager.set_clip_request")) {
    return nullptr;
  }
  // 1-void CTMusicManager::set_clip_request(std::string const &clip)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_clip_request)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_clip_request(const CTMusicManager self, str clip)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CTMusicManager_set_clip_request_28_comment =
  "C++ Interface:\n"
  "set_clip_request(const CTMusicManager self, str clip)\n";
#else
static const char *Dtool_CTMusicManager_set_clip_request_28_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string CTMusicManager::get_clip_request(void) const
 */
static PyObject *Dtool_CTMusicManager_get_clip_request_29(PyObject *self, PyObject *) {
  CTMusicManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CTMusicManager)) {
    return nullptr;
  }
  // 1-std::string CTMusicManager::get_clip_request(void) const
  std::string return_value = ((*(const CTMusicManager*)local_this).get_clip_request)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CTMusicManager_get_clip_request_29_comment =
  "C++ Interface:\n"
  "get_clip_request(CTMusicManager self)\n";
#else
static const char *Dtool_CTMusicManager_get_clip_request_29_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CTMusicManager::start_music(std::string const &base_or_orc)
 */
static PyObject *Dtool_CTMusicManager_start_music_30(PyObject *self, PyObject *arg) {
  CTMusicManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CTMusicManager, (void **)&local_this, "CTMusicManager.start_music")) {
    return nullptr;
  }
  // 1-void CTMusicManager::start_music(std::string const &base_or_orc)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).start_music)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "start_music(const CTMusicManager self, str base_or_orc)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CTMusicManager_start_music_30_comment =
  "C++ Interface:\n"
  "start_music(const CTMusicManager self, str base_or_orc)\n";
#else
static const char *Dtool_CTMusicManager_start_music_30_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CTMusicManager::stop_clip(void)
 */
static PyObject *Dtool_CTMusicManager_stop_clip_31(PyObject *self, PyObject *) {
  CTMusicManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CTMusicManager, (void **)&local_this, "CTMusicManager.stop_clip")) {
    return nullptr;
  }
  // 1-void CTMusicManager::stop_clip(void)
  ((*local_this).stop_clip)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CTMusicManager_stop_clip_31_comment =
  "C++ Interface:\n"
  "stop_clip(const CTMusicManager self)\n";
#else
static const char *Dtool_CTMusicManager_stop_clip_31_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static bool CTMusicManager::is_loaded(void)
 */
static PyObject *Dtool_CTMusicManager_is_loaded_32(PyObject *, PyObject *) {
  // 1-static bool CTMusicManager::is_loaded(void)
  bool return_value = (CTMusicManager::is_loaded)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CTMusicManager_is_loaded_32_comment =
  "C++ Interface:\n"
  "is_loaded()\n";
#else
static const char *Dtool_CTMusicManager_is_loaded_32_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CTMusicManager::set_song_name(std::string const &name)
 */
static PyObject *Dtool_CTMusicManager_set_song_name_33(PyObject *self, PyObject *arg) {
  CTMusicManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CTMusicManager, (void **)&local_this, "CTMusicManager.set_song_name")) {
    return nullptr;
  }
  // 1-void CTMusicManager::set_song_name(std::string const &name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_song_name)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_song_name(const CTMusicManager self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CTMusicManager_set_song_name_33_comment =
  "C++ Interface:\n"
  "set_song_name(const CTMusicManager self, str name)\n";
#else
static const char *Dtool_CTMusicManager_set_song_name_33_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string CTMusicManager::get_song_name(void) const
 */
static PyObject *Dtool_CTMusicManager_get_song_name_34(PyObject *self, PyObject *) {
  CTMusicManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CTMusicManager)) {
    return nullptr;
  }
  // 1-std::string CTMusicManager::get_song_name(void) const
  std::string return_value = ((*(const CTMusicManager*)local_this).get_song_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CTMusicManager_get_song_name_34_comment =
  "C++ Interface:\n"
  "get_song_name(CTMusicManager self)\n";
#else
static const char *Dtool_CTMusicManager_get_song_name_34_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string CTMusicManager::get_clip_name(void) const
 */
static PyObject *Dtool_CTMusicManager_get_clip_name_35(PyObject *self, PyObject *) {
  CTMusicManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CTMusicManager)) {
    return nullptr;
  }
  // 1-std::string CTMusicManager::get_clip_name(void) const
  std::string return_value = ((*(const CTMusicManager*)local_this).get_clip_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CTMusicManager_get_clip_name_35_comment =
  "C++ Interface:\n"
  "get_clip_name(CTMusicManager self)\n";
#else
static const char *Dtool_CTMusicManager_get_clip_name_35_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string CTMusicManager::get_curr_style(void) const
 */
static PyObject *Dtool_CTMusicManager_get_curr_style_36(PyObject *self, PyObject *) {
  CTMusicManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CTMusicManager)) {
    return nullptr;
  }
  // 1-std::string CTMusicManager::get_curr_style(void) const
  std::string return_value = ((*(const CTMusicManager*)local_this).get_curr_style)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CTMusicManager_get_curr_style_36_comment =
  "C++ Interface:\n"
  "get_curr_style(CTMusicManager self)\n";
#else
static const char *Dtool_CTMusicManager_get_curr_style_36_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CTMusicManager::handle_part_done(int part_index)
 */
static PyObject *Dtool_CTMusicManager_handle_part_done_37(PyObject *self, PyObject *arg) {
  CTMusicManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CTMusicManager, (void **)&local_this, "CTMusicManager.handle_part_done")) {
    return nullptr;
  }
  // 1-void CTMusicManager::handle_part_done(int part_index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).handle_part_done)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "handle_part_done(const CTMusicManager self, int part_index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CTMusicManager_handle_part_done_37_comment =
  "C++ Interface:\n"
  "handle_part_done(const CTMusicManager self, int part_index)\n";
#else
static const char *Dtool_CTMusicManager_handle_part_done_37_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * CTMusicManager::CTMusicManager(void)
 * inline CTMusicManager::CTMusicManager(CTMusicManager const &) = default
 */
static int Dtool_Init_CTMusicManager(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("CTMusicManager() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-CTMusicManager::CTMusicManager(void)
      CTMusicManager *return_value = new CTMusicManager();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CTMusicManager, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline CTMusicManager::CTMusicManager(CTMusicManager const &) = default
      CTMusicManager const *arg_this = (CTMusicManager *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CTMusicManager, 0, "CTMusicManager.CTMusicManager", true, true);
      if (arg_this != nullptr) {
        CTMusicManager *return_value = new CTMusicManager(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CTMusicManager, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CTMusicManager() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CTMusicManager()\n"
      "CTMusicManager(const CTMusicManager param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CTMusicManager(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CTMusicManager) {
    printf("CTMusicManager ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CTMusicManager *local_this = (CTMusicManager *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CTMusicManager) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CTMusicManager(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CTMusicManager) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class Lerper
 */
/**
 * Python function wrapper for:
 * PN_stdfloat Lerper::lerp_to_float(PN_stdfloat goal)
 */
static PyObject *Dtool_Lerper_lerp_to_float_40(PyObject *self, PyObject *arg) {
  Lerper *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Lerper, (void **)&local_this, "Lerper.lerp_to_float")) {
    return nullptr;
  }
  // 1-PN_stdfloat Lerper::lerp_to_float(PN_stdfloat goal)
  if (PyNumber_Check(arg)) {
    PN_stdfloat return_value = ((*local_this).lerp_to_float)((PN_stdfloat)PyFloat_AsDouble(arg));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "lerp_to_float(const Lerper self, float goal)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Lerper_lerp_to_float_40_comment =
  "C++ Interface:\n"
  "lerp_to_float(const Lerper self, float goal)\n";
#else
static const char *Dtool_Lerper_lerp_to_float_40_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LPoint3f &Lerper::lerp_to_p3(LPoint3f &goal)
 */
static PyObject *Dtool_Lerper_lerp_to_p3_41(PyObject *self, PyObject *arg) {
  Lerper *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Lerper, (void **)&local_this, "Lerper.lerp_to_p3")) {
    return nullptr;
  }
  // 1-LPoint3f &Lerper::lerp_to_p3(LPoint3f &goal)
  LPoint3f arg_local;
  LPoint3f *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Lerper.lerp_to_p3", "LPoint3f");
  }
  LPoint3f *return_value = &(((*local_this).lerp_to_p3)(*arg_this));
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "lerp_to_p3(const Lerper self, LPoint3f goal)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Lerper_lerp_to_p3_41_comment =
  "C++ Interface:\n"
  "lerp_to_p3(const Lerper self, LPoint3f goal)\n";
#else
static const char *Dtool_Lerper_lerp_to_p3_41_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Lerper::set_last_float(PN_stdfloat val)
 */
static PyObject *Dtool_Lerper_set_last_float_42(PyObject *self, PyObject *arg) {
  Lerper *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Lerper, (void **)&local_this, "Lerper.set_last_float")) {
    return nullptr;
  }
  // 1-void Lerper::set_last_float(PN_stdfloat val)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_last_float)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_last_float(const Lerper self, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Lerper_set_last_float_42_comment =
  "C++ Interface:\n"
  "set_last_float(const Lerper self, float val)\n";
#else
static const char *Dtool_Lerper_set_last_float_42_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Lerper::set_last_p3(LPoint3f &val)
 */
static PyObject *Dtool_Lerper_set_last_p3_43(PyObject *self, PyObject *arg) {
  Lerper *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Lerper, (void **)&local_this, "Lerper.set_last_p3")) {
    return nullptr;
  }
  // 1-void Lerper::set_last_p3(LPoint3f &val)
  LPoint3f arg_local;
  LPoint3f *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Lerper.set_last_p3", "LPoint3f");
  }
  ((*local_this).set_last_p3)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_last_p3(const Lerper self, LPoint3f val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Lerper_set_last_p3_43_comment =
  "C++ Interface:\n"
  "set_last_p3(const Lerper self, LPoint3f val)\n";
#else
static const char *Dtool_Lerper_set_last_p3_43_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LPoint3f const &Lerper::get_last_p3(void) const
 */
static PyObject *Dtool_Lerper_get_last_p3_44(PyObject *self, PyObject *) {
  Lerper *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Lerper)) {
    return nullptr;
  }
  // 1-LPoint3f const &Lerper::get_last_p3(void) const
  LPoint3f const *return_value = &(((*(const Lerper*)local_this).get_last_p3)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Lerper_get_last_p3_44_comment =
  "C++ Interface:\n"
  "get_last_p3(Lerper self)\n";
#else
static const char *Dtool_Lerper_get_last_p3_44_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PN_stdfloat Lerper::get_last_float(void) const
 */
static PyObject *Dtool_Lerper_get_last_float_45(PyObject *self, PyObject *) {
  Lerper *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Lerper)) {
    return nullptr;
  }
  // 1-PN_stdfloat Lerper::get_last_float(void) const
  PN_stdfloat return_value = ((*(const Lerper*)local_this).get_last_float)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Lerper_get_last_float_45_comment =
  "C++ Interface:\n"
  "get_last_float(Lerper self)\n";
#else
static const char *Dtool_Lerper_get_last_float_45_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Lerper::set_lerp_ratio(PN_stdfloat lerp_ratio)
 */
static PyObject *Dtool_Lerper_set_lerp_ratio_46(PyObject *self, PyObject *arg) {
  Lerper *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Lerper, (void **)&local_this, "Lerper.set_lerp_ratio")) {
    return nullptr;
  }
  // 1-void Lerper::set_lerp_ratio(PN_stdfloat lerp_ratio)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_lerp_ratio)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_lerp_ratio(const Lerper self, float lerp_ratio)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Lerper_set_lerp_ratio_46_comment =
  "C++ Interface:\n"
  "set_lerp_ratio(const Lerper self, float lerp_ratio)\n";
#else
static const char *Dtool_Lerper_set_lerp_ratio_46_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PN_stdfloat Lerper::get_lerp_ratio(void) const
 */
static PyObject *Dtool_Lerper_get_lerp_ratio_47(PyObject *self, PyObject *) {
  Lerper *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Lerper)) {
    return nullptr;
  }
  // 1-PN_stdfloat Lerper::get_lerp_ratio(void) const
  PN_stdfloat return_value = ((*(const Lerper*)local_this).get_lerp_ratio)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Lerper_get_lerp_ratio_47_comment =
  "C++ Interface:\n"
  "get_lerp_ratio(Lerper self)\n";
#else
static const char *Dtool_Lerper_get_lerp_ratio_47_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Lerper::Lerper(LPoint3f &initial_p3, PN_stdfloat lerp_ratio)
 * inline Lerper::Lerper(Lerper const &) = default
 * Lerper::Lerper(PN_stdfloat initial_val, PN_stdfloat lerp_ratio)
 */
static int Dtool_Init_Lerper(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    if (kwds == nullptr || PyDict_GET_SIZE(kwds) == 0) {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline Lerper::Lerper(Lerper const &) = default
      Lerper const *arg_this = (Lerper *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Lerper, 0, "Lerper.Lerper", true, true);
      if (arg_this != nullptr) {
        Lerper *return_value = new Lerper(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Lerper, true, false);
      }
    }
    break;
  case 2:
    {
      {
        // -2 Lerper::Lerper(LPoint3f &initial_p3, PN_stdfloat lerp_ratio)
        PyObject *param0;
        float param1;
        static const char *keyword_list[] = {"initial_p3", "lerp_ratio", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:Lerper", (char **)keyword_list, &param0, &param1)) {
          LPoint3f *param0_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LPoint3f, 0, "Lerper.Lerper", false, false);
          if (param0_this != nullptr) {
            Lerper *return_value = new Lerper(*param0_this, (PN_stdfloat)param1);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Lerper, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 Lerper::Lerper(PN_stdfloat initial_val, PN_stdfloat lerp_ratio)
        float param0;
        float param1;
        static const char *keyword_list[] = {"initial_val", "lerp_ratio", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:Lerper", (char **)keyword_list, &param0, &param1)) {
          Lerper *return_value = new Lerper((PN_stdfloat)param0, (PN_stdfloat)param1);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Lerper, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 Lerper::Lerper(LPoint3f &initial_p3, PN_stdfloat lerp_ratio)
        PyObject *param0;
        float param1;
        static const char *keyword_list[] = {"initial_p3", "lerp_ratio", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:Lerper", (char **)keyword_list, &param0, &param1)) {
          LPoint3f param0_local;
          LPoint3f *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
          if ((param0_this != nullptr)) {
            Lerper *return_value = new Lerper(*param0_this, (PN_stdfloat)param1);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Lerper, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: Lerper::Lerper(PN_stdfloat initial_val, PN_stdfloat lerp_ratio)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Lerper() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Lerper(const Lerper param0)\n"
      "Lerper(LPoint3f initial_p3, float lerp_ratio)\n"
      "Lerper(float initial_val, float lerp_ratio)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_Lerper(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_Lerper) {
    printf("Lerper ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  Lerper *local_this = (Lerper *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_Lerper) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_Lerper(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_Lerper) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class SuitPathFinderAI
 */
/**
 * Python function wrapper for:
 * PyObject *SuitPathFinderAI::plan_path(PyObject *from, PyObject *to, PN_stdfloat close_enough = 0.0)
 */
static PyObject *Dtool_SuitPathFinderAI_plan_path_51(PyObject *self, PyObject *args, PyObject *kwds) {
  SuitPathFinderAI *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SuitPathFinderAI, (void **)&local_this, "SuitPathFinderAI.plan_path")) {
    return nullptr;
  }
  // 1-PyObject *SuitPathFinderAI::plan_path(PyObject *from, PyObject *to, PN_stdfloat close_enough = 0.0)
  PyObject *param1;
  PyObject *param2;
  float param3 = 0.0;
  static const char *keyword_list[] = {"from", "to", "close_enough", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO|f:plan_path", (char **)keyword_list, &param1, &param2, &param3)) {
    PyObject *return_value = ((*local_this).plan_path)(param1, param2, (PN_stdfloat)param3);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "plan_path(const SuitPathFinderAI self, object from, object to, float close_enough)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SuitPathFinderAI_plan_path_51_comment =
  "C++ Interface:\n"
  "plan_path(const SuitPathFinderAI self, object from, object to, float close_enough)\n"
  "\n"
  "//                       tuple           tuple";
#else
static const char *Dtool_SuitPathFinderAI_plan_path_51_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void SuitPathFinderAI::add_polygon(PyObject *points)
 */
static PyObject *Dtool_SuitPathFinderAI_add_polygon_52(PyObject *self, PyObject *arg) {
  SuitPathFinderAI *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SuitPathFinderAI, (void **)&local_this, "SuitPathFinderAI.add_polygon")) {
    return nullptr;
  }
  // 1-void SuitPathFinderAI::add_polygon(PyObject *points)
  ((*local_this).add_polygon)(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_polygon(const SuitPathFinderAI self, object points)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SuitPathFinderAI_add_polygon_52_comment =
  "C++ Interface:\n"
  "add_polygon(const SuitPathFinderAI self, object points)\n"
  "\n"
  "//      list";
#else
static const char *Dtool_SuitPathFinderAI_add_polygon_52_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void SuitPathFinderAI::build_neighbors(void)
 */
static PyObject *Dtool_SuitPathFinderAI_build_neighbors_53(PyObject *self, PyObject *) {
  SuitPathFinderAI *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SuitPathFinderAI, (void **)&local_this, "SuitPathFinderAI.build_neighbors")) {
    return nullptr;
  }
  // 1-void SuitPathFinderAI::build_neighbors(void)
  ((*local_this).build_neighbors)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_SuitPathFinderAI_build_neighbors_53_comment =
  "C++ Interface:\n"
  "build_neighbors(const SuitPathFinderAI self)\n";
#else
static const char *Dtool_SuitPathFinderAI_build_neighbors_53_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * SuitPathFinderAI::SuitPathFinderAI(PyObject *polygons = nullptr)
 * inline SuitPathFinderAI::SuitPathFinderAI(SuitPathFinderAI const &) = default
 */
static int Dtool_Init_SuitPathFinderAI(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-SuitPathFinderAI::SuitPathFinderAI(PyObject *polygons)
      SuitPathFinderAI *return_value = new SuitPathFinderAI();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SuitPathFinderAI, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline SuitPathFinderAI::SuitPathFinderAI(SuitPathFinderAI const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          SuitPathFinderAI const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_SuitPathFinderAI);
          if (param0_this != nullptr) {
            SuitPathFinderAI *return_value = new SuitPathFinderAI(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SuitPathFinderAI, true, false);
          }
        }
      }

      {
        // -2 SuitPathFinderAI::SuitPathFinderAI(PyObject *polygons)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "polygons")) {
          SuitPathFinderAI *return_value = new SuitPathFinderAI(param0);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          PyObject *exception = _PyErr_OCCURRED();
          if (exception == PyExc_TypeError) {
            // TypeError raised; continue to next overload type.
          } else if (exception != nullptr) {
            delete return_value;
            return -1;
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (UNLIKELY(notify->has_assert_failed())) {
              delete return_value;
              Dtool_Raise_AssertionError();
              return -1;
            }
#endif
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SuitPathFinderAI, true, false);
          }
        }
      }

      {
        // -2 inline SuitPathFinderAI::SuitPathFinderAI(SuitPathFinderAI const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          SuitPathFinderAI param0_local;
          SuitPathFinderAI const *param0_this = Dtool_Coerce_SuitPathFinderAI(param0, param0_local);
          if ((param0_this != nullptr)) {
            SuitPathFinderAI *return_value = new SuitPathFinderAI(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SuitPathFinderAI, true, false);
          }
        }
      }

      // No coercion possible: SuitPathFinderAI::SuitPathFinderAI(PyObject *polygons)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "SuitPathFinderAI() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "SuitPathFinderAI()\n"
      "SuitPathFinderAI(const SuitPathFinderAI param0)\n"
      "SuitPathFinderAI(object polygons)\n");
  }
  return -1;
}

SuitPathFinderAI *Dtool_Coerce_SuitPathFinderAI(PyObject *args, SuitPathFinderAI &coerced) {
  SuitPathFinderAI *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_SuitPathFinderAI)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const SuitPathFinderAI *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-SuitPathFinderAI::SuitPathFinderAI(PyObject *polygons)
    coerced = SuitPathFinderAI(arg);
    PyObject *exception = _PyErr_OCCURRED();
    if (exception == PyExc_TypeError) {
      // TypeError raised; continue to next overload type.
    } else if (exception != nullptr) {
      return nullptr;
    } else {
      return &coerced;
    }
  }
  return nullptr;
}

static void *Dtool_UpcastInterface_SuitPathFinderAI(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_SuitPathFinderAI) {
    printf("SuitPathFinderAI ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  SuitPathFinderAI *local_this = (SuitPathFinderAI *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_SuitPathFinderAI) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_SuitPathFinderAI(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_SuitPathFinderAI) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python method tables for AudioClip (AudioClip)
 */
static PyMethodDef Dtool_Methods_AudioClip[] = {
  {"get_clip_done_event", &Dtool_AudioClip_get_clip_done_event_2, METH_NOARGS | METH_STATIC, (const char *)Dtool_AudioClip_get_clip_done_event_2_comment},
  {"getClipDoneEvent", &Dtool_AudioClip_get_clip_done_event_2, METH_NOARGS | METH_STATIC, (const char *)Dtool_AudioClip_get_clip_done_event_2_comment},
  {"get_part_done_event", &Dtool_AudioClip_get_part_done_event_3, METH_NOARGS | METH_STATIC, (const char *)Dtool_AudioClip_get_part_done_event_3_comment},
  {"getPartDoneEvent", &Dtool_AudioClip_get_part_done_event_3, METH_NOARGS | METH_STATIC, (const char *)Dtool_AudioClip_get_part_done_event_3_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_AudioClip = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_AudioClip = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "ccoginvasion.AudioClip",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_AudioClip,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_AudioClip,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_AudioClip,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_AudioClip,
    PyType_GenericAlloc,
    Dtool_new_AudioClip,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AudioClip,
  Dtool_UpcastInterface_AudioClip,
  Dtool_DowncastInterface_AudioClip,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_AudioClip(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_AudioClip._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_AudioClip._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AudioClip) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AudioClip)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AudioClip);
  }
}

/**
 * Python method tables for CNametag (CNametag)
 */
static PyMethodDef Dtool_Methods_CNametag[] = {
  {"set_chatballoon_size", (PyCFunction) &Dtool_CNametag_set_chatballoon_size_9, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CNametag_set_chatballoon_size_9_comment},
  {"setChatballoonSize", (PyCFunction) &Dtool_CNametag_set_chatballoon_size_9, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CNametag_set_chatballoon_size_9_comment},
  {"set_panel_size", (PyCFunction) &Dtool_CNametag_set_panel_size_10, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CNametag_set_panel_size_10_comment},
  {"setPanelSize", (PyCFunction) &Dtool_CNametag_set_panel_size_10, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CNametag_set_panel_size_10_comment},
  {"get_chatballoon_region", &Dtool_CNametag_get_chatballoon_region_12, METH_O, (const char *)Dtool_CNametag_get_chatballoon_region_12_comment},
  {"getChatballoonRegion", &Dtool_CNametag_get_chatballoon_region_12, METH_O, (const char *)Dtool_CNametag_get_chatballoon_region_12_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CNametag = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_CNametag = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "ccoginvasion.CNametag",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CNametag,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CNametag,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CNametag,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CNametag,
    PyType_GenericAlloc,
    Dtool_new_CNametag,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CNametag,
  Dtool_UpcastInterface_CNametag,
  Dtool_DowncastInterface_CNametag,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CNametag(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_CNametag._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CNametag._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CNametag) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CNametag)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CNametag);
  }
}

/**
 * Python method tables for CNametag3d (CNametag3d)
 */
static PyMethodDef Dtool_Methods_CNametag3d[] = {
  {"get_chatballoon_region", (PyCFunction) &Dtool_CNametag3d_get_chatballoon_region_15, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CNametag3d_get_chatballoon_region_15_comment},
  {"getChatballoonRegion", (PyCFunction) &Dtool_CNametag3d_get_chatballoon_region_15, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CNametag3d_get_chatballoon_region_15_comment},
  {"get_scale", (PyCFunction) &Dtool_CNametag3d_get_scale_16, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CNametag3d_get_scale_16_comment},
  {"getScale", (PyCFunction) &Dtool_CNametag3d_get_scale_16, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CNametag3d_get_scale_16_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CNametag3d = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CNametag3d = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CNametag3d = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CNametag3d = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CNametag3d = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CNametag3d = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "ccoginvasion.CNametag3d",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CNametag3d,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CNametag3d,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CNametag3d,
    &Dtool_SequenceMethods_CNametag3d,
    &Dtool_MappingMethods_CNametag3d,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CNametag3d,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CNametag3d,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CNametag3d,
    PyType_GenericAlloc,
    Dtool_new_CNametag3d,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CNametag3d,
  Dtool_UpcastInterface_CNametag3d,
  Dtool_DowncastInterface_CNametag3d,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CNametag3d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CNametag(nullptr);
    Dtool_CNametag3d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CNametag);
    Dtool_CNametag3d._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CNametag3d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CNametag3d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CNametag3d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CNametag3d);
  }
}

/**
 * Python method tables for CTMusicData (CTMusicData)
 */
static PyMethodDef Dtool_Methods_CTMusicData[] = {
  {"initialize_chunk_data", &Dtool_CTMusicData_initialize_chunk_data_22, METH_NOARGS | METH_STATIC, (const char *)Dtool_CTMusicData_initialize_chunk_data_22_comment},
  {"initializeChunkData", &Dtool_CTMusicData_initialize_chunk_data_22, METH_NOARGS | METH_STATIC, (const char *)Dtool_CTMusicData_initialize_chunk_data_22_comment},
  {"stop_am_update_task", &Dtool_CTMusicData_stop_am_update_task_23, METH_NOARGS | METH_STATIC, (const char *)Dtool_CTMusicData_stop_am_update_task_23_comment},
  {"stopAmUpdateTask", &Dtool_CTMusicData_stop_am_update_task_23, METH_NOARGS | METH_STATIC, (const char *)Dtool_CTMusicData_stop_am_update_task_23_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CTMusicData = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_CTMusicData = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "ccoginvasion.CTMusicData",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CTMusicData,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CTMusicData,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CTMusicData,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CTMusicData,
    PyType_GenericAlloc,
    Dtool_new_CTMusicData,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CTMusicData,
  Dtool_UpcastInterface_CTMusicData,
  Dtool_DowncastInterface_CTMusicData,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CTMusicData(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_CTMusicData._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CTMusicData._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CTMusicData) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CTMusicData)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CTMusicData);
  }
}

/**
 * Python method tables for CTMusicManager (CTMusicManager)
 */
static PyMethodDef Dtool_Methods_CTMusicManager[] = {
  {"spawn_load_tournament_music_task", &Dtool_CTMusicManager_spawn_load_tournament_music_task_27, METH_NOARGS | METH_STATIC, (const char *)Dtool_CTMusicManager_spawn_load_tournament_music_task_27_comment},
  {"spawnLoadTournamentMusicTask", &Dtool_CTMusicManager_spawn_load_tournament_music_task_27, METH_NOARGS | METH_STATIC, (const char *)Dtool_CTMusicManager_spawn_load_tournament_music_task_27_comment},
  {"set_clip_request", &Dtool_CTMusicManager_set_clip_request_28, METH_O, (const char *)Dtool_CTMusicManager_set_clip_request_28_comment},
  {"setClipRequest", &Dtool_CTMusicManager_set_clip_request_28, METH_O, (const char *)Dtool_CTMusicManager_set_clip_request_28_comment},
  {"get_clip_request", &Dtool_CTMusicManager_get_clip_request_29, METH_NOARGS, (const char *)Dtool_CTMusicManager_get_clip_request_29_comment},
  {"getClipRequest", &Dtool_CTMusicManager_get_clip_request_29, METH_NOARGS, (const char *)Dtool_CTMusicManager_get_clip_request_29_comment},
  {"start_music", &Dtool_CTMusicManager_start_music_30, METH_O, (const char *)Dtool_CTMusicManager_start_music_30_comment},
  {"startMusic", &Dtool_CTMusicManager_start_music_30, METH_O, (const char *)Dtool_CTMusicManager_start_music_30_comment},
  {"stop_clip", &Dtool_CTMusicManager_stop_clip_31, METH_NOARGS, (const char *)Dtool_CTMusicManager_stop_clip_31_comment},
  {"stopClip", &Dtool_CTMusicManager_stop_clip_31, METH_NOARGS, (const char *)Dtool_CTMusicManager_stop_clip_31_comment},
  {"is_loaded", &Dtool_CTMusicManager_is_loaded_32, METH_NOARGS | METH_STATIC, (const char *)Dtool_CTMusicManager_is_loaded_32_comment},
  {"isLoaded", &Dtool_CTMusicManager_is_loaded_32, METH_NOARGS | METH_STATIC, (const char *)Dtool_CTMusicManager_is_loaded_32_comment},
  {"set_song_name", &Dtool_CTMusicManager_set_song_name_33, METH_O, (const char *)Dtool_CTMusicManager_set_song_name_33_comment},
  {"setSongName", &Dtool_CTMusicManager_set_song_name_33, METH_O, (const char *)Dtool_CTMusicManager_set_song_name_33_comment},
  {"get_song_name", &Dtool_CTMusicManager_get_song_name_34, METH_NOARGS, (const char *)Dtool_CTMusicManager_get_song_name_34_comment},
  {"getSongName", &Dtool_CTMusicManager_get_song_name_34, METH_NOARGS, (const char *)Dtool_CTMusicManager_get_song_name_34_comment},
  {"get_clip_name", &Dtool_CTMusicManager_get_clip_name_35, METH_NOARGS, (const char *)Dtool_CTMusicManager_get_clip_name_35_comment},
  {"getClipName", &Dtool_CTMusicManager_get_clip_name_35, METH_NOARGS, (const char *)Dtool_CTMusicManager_get_clip_name_35_comment},
  {"get_curr_style", &Dtool_CTMusicManager_get_curr_style_36, METH_NOARGS, (const char *)Dtool_CTMusicManager_get_curr_style_36_comment},
  {"getCurrStyle", &Dtool_CTMusicManager_get_curr_style_36, METH_NOARGS, (const char *)Dtool_CTMusicManager_get_curr_style_36_comment},
  {"handle_part_done", &Dtool_CTMusicManager_handle_part_done_37, METH_O, (const char *)Dtool_CTMusicManager_handle_part_done_37_comment},
  {"handlePartDone", &Dtool_CTMusicManager_handle_part_done_37, METH_O, (const char *)Dtool_CTMusicManager_handle_part_done_37_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CTMusicManager = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_CTMusicManager = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "ccoginvasion.CTMusicManager",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CTMusicManager,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CTMusicManager,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CTMusicManager,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CTMusicManager,
    PyType_GenericAlloc,
    Dtool_new_CTMusicManager,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CTMusicManager,
  Dtool_UpcastInterface_CTMusicManager,
  Dtool_DowncastInterface_CTMusicManager,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CTMusicManager(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_CTMusicManager._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CTMusicManager._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CTMusicManager) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CTMusicManager)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CTMusicManager);
  }
}

/**
 * Python method tables for Lerper (Lerper)
 */
static PyMethodDef Dtool_Methods_Lerper[] = {
  {"lerp_to_float", &Dtool_Lerper_lerp_to_float_40, METH_O, (const char *)Dtool_Lerper_lerp_to_float_40_comment},
  {"lerpToFloat", &Dtool_Lerper_lerp_to_float_40, METH_O, (const char *)Dtool_Lerper_lerp_to_float_40_comment},
  {"lerp_to_p3", &Dtool_Lerper_lerp_to_p3_41, METH_O, (const char *)Dtool_Lerper_lerp_to_p3_41_comment},
  {"lerpToP3", &Dtool_Lerper_lerp_to_p3_41, METH_O, (const char *)Dtool_Lerper_lerp_to_p3_41_comment},
  {"set_last_float", &Dtool_Lerper_set_last_float_42, METH_O, (const char *)Dtool_Lerper_set_last_float_42_comment},
  {"setLastFloat", &Dtool_Lerper_set_last_float_42, METH_O, (const char *)Dtool_Lerper_set_last_float_42_comment},
  {"set_last_p3", &Dtool_Lerper_set_last_p3_43, METH_O, (const char *)Dtool_Lerper_set_last_p3_43_comment},
  {"setLastP3", &Dtool_Lerper_set_last_p3_43, METH_O, (const char *)Dtool_Lerper_set_last_p3_43_comment},
  {"get_last_p3", &Dtool_Lerper_get_last_p3_44, METH_NOARGS, (const char *)Dtool_Lerper_get_last_p3_44_comment},
  {"getLastP3", &Dtool_Lerper_get_last_p3_44, METH_NOARGS, (const char *)Dtool_Lerper_get_last_p3_44_comment},
  {"get_last_float", &Dtool_Lerper_get_last_float_45, METH_NOARGS, (const char *)Dtool_Lerper_get_last_float_45_comment},
  {"getLastFloat", &Dtool_Lerper_get_last_float_45, METH_NOARGS, (const char *)Dtool_Lerper_get_last_float_45_comment},
  {"set_lerp_ratio", &Dtool_Lerper_set_lerp_ratio_46, METH_O, (const char *)Dtool_Lerper_set_lerp_ratio_46_comment},
  {"setLerpRatio", &Dtool_Lerper_set_lerp_ratio_46, METH_O, (const char *)Dtool_Lerper_set_lerp_ratio_46_comment},
  {"get_lerp_ratio", &Dtool_Lerper_get_lerp_ratio_47, METH_NOARGS, (const char *)Dtool_Lerper_get_lerp_ratio_47_comment},
  {"getLerpRatio", &Dtool_Lerper_get_lerp_ratio_47, METH_NOARGS, (const char *)Dtool_Lerper_get_lerp_ratio_47_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_Lerper = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_Lerper = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "ccoginvasion.Lerper",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_Lerper,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_Lerper,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_Lerper,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_Lerper,
    PyType_GenericAlloc,
    Dtool_new_Lerper,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Lerper,
  Dtool_UpcastInterface_Lerper,
  Dtool_DowncastInterface_Lerper,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_Lerper(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_Lerper._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_Lerper._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Lerper) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Lerper)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Lerper);
  }
}

/**
 * Python method tables for SuitPathFinderAI (SuitPathFinderAI)
 */
static PyMethodDef Dtool_Methods_SuitPathFinderAI[] = {
  {"plan_path", (PyCFunction) &Dtool_SuitPathFinderAI_plan_path_51, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SuitPathFinderAI_plan_path_51_comment},
  {"planPath", (PyCFunction) &Dtool_SuitPathFinderAI_plan_path_51, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SuitPathFinderAI_plan_path_51_comment},
  {"add_polygon", &Dtool_SuitPathFinderAI_add_polygon_52, METH_O, (const char *)Dtool_SuitPathFinderAI_add_polygon_52_comment},
  {"addPolygon", &Dtool_SuitPathFinderAI_add_polygon_52, METH_O, (const char *)Dtool_SuitPathFinderAI_add_polygon_52_comment},
  {"build_neighbors", &Dtool_SuitPathFinderAI_build_neighbors_53, METH_NOARGS, (const char *)Dtool_SuitPathFinderAI_build_neighbors_53_comment},
  {"buildNeighbors", &Dtool_SuitPathFinderAI_build_neighbors_53, METH_NOARGS, (const char *)Dtool_SuitPathFinderAI_build_neighbors_53_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_SuitPathFinderAI = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_SuitPathFinderAI = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "ccoginvasion.SuitPathFinderAI",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_SuitPathFinderAI,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_SuitPathFinderAI,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_SuitPathFinderAI,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_SuitPathFinderAI,
    PyType_GenericAlloc,
    Dtool_new_SuitPathFinderAI,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_SuitPathFinderAI,
  Dtool_UpcastInterface_SuitPathFinderAI,
  Dtool_DowncastInterface_SuitPathFinderAI,
  nullptr,
  (CoerceFunction)Dtool_Coerce_SuitPathFinderAI,
};

static void Dtool_PyModuleClassInit_SuitPathFinderAI(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_SuitPathFinderAI._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_SuitPathFinderAI._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_SuitPathFinderAI) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(SuitPathFinderAI)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_SuitPathFinderAI);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_ccoginvasion_RegisterTypes() {
  TypeRegistry *registry = TypeRegistry::ptr();
  nassertv(registry != nullptr);
}

void Dtool_ccoginvasion_BuildInstants(PyObject *module) {
  (void) module;
  // AudioClip
  Dtool_PyModuleClassInit_AudioClip(module);
  PyModule_AddObject(module, "AudioClip", (PyObject *)&Dtool_AudioClip);
  // CNametag
  Dtool_PyModuleClassInit_CNametag(module);
  PyModule_AddObject(module, "CNametag", (PyObject *)&Dtool_CNametag);
  // CNametag3d
  Dtool_PyModuleClassInit_CNametag3d(module);
  PyModule_AddObject(module, "CNametag3d", (PyObject *)&Dtool_CNametag3d);
  // CTMusicData
  Dtool_PyModuleClassInit_CTMusicData(module);
  PyModule_AddObject(module, "CTMusicData", (PyObject *)&Dtool_CTMusicData);
  // CTMusicManager
  Dtool_PyModuleClassInit_CTMusicManager(module);
  PyModule_AddObject(module, "CTMusicManager", (PyObject *)&Dtool_CTMusicManager);
  // Lerper
  Dtool_PyModuleClassInit_Lerper(module);
  PyModule_AddObject(module, "Lerper", (PyObject *)&Dtool_Lerper);
  // SuitPathFinderAI
  Dtool_PyModuleClassInit_SuitPathFinderAI(module);
  PyModule_AddObject(module, "SuitPathFinderAI", (PyObject *)&Dtool_SuitPathFinderAI);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {nullptr, nullptr, 0, nullptr}
};

#ifdef LINK_ALL_STATIC
extern const struct LibraryDef ccoginvasion_moddef = {python_simple_funcs, exports, nullptr};
#else
extern const struct LibraryDef ccoginvasion_moddef = {python_simple_funcs, exports, imports};
#endif
static InterrogateModuleDef _in_module_def = {
  1585753803,  /* file_identifier */
  "ccoginvasion",  /* library_name */
  "_5Dz",  /* library_hash_name */
  "ccoginvasion",  /* module_name */
  "ccoginvasion.in",  /* database_filename */
  nullptr,  /* unique_names */
  0,  /* num_unique_names */
  nullptr,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  139  /* next_index */
};

Configure(_in_configure_ccoginvasion);
ConfigureFn(_in_configure_ccoginvasion) {
  interrogate_request_module(&_in_module_def);
}

